/**
 * ToneSoul Law Layer - Data Contracts
 * Defines the structure of Responsibility and Memory along with helper types
 * and a factory for constructing vows.  This file is intended to be
 * production ready and can be consumed by type‑checked environments.
 */

// -----------------------------
// ToneSoul Triad
// -----------------------------
export interface ToneSoulTriad {
  /**
   * Tension (0.0 – 1.0): emotional intensity.  Higher values indicate
   * stronger emotional charge or urgency in the user's request.
   */
  delta_t: number;
  /**
   * Drift (0.0 – 1.0): semantic deviation from the current context.  A value
   * closer to 1 means the request stays on topic; lower values signal drift.
   */
  delta_s: number;
  /**
   * Responsibility (0.0 – 1.0): risk or liability level associated with
   * fulfilling the request.  High values reflect topics like medical,
   * financial or legal advice.
   */
  delta_r: number;
  /**
   * Weighted risk score derived from the three deltas.  It is a composite
   * measure used to decide whether to invoke guardian mode.
   */
  risk_score: number;
}

// -----------------------------
// Responsibility Levels
// -----------------------------
export enum ResponsibilityLevel {
  /** Low risk: general conversation and benign topics. */
  LOW = "LOW",
  /** Medium risk: topics requiring caution (e.g., creative suggestions). */
  MED = "MED",
  /** High risk: topics like basic legal or financial information. */
  HIGH = "HIGH",
  /** Critical risk: topics that may cause harm if mishandled (e.g., medical advice). */
  CRITICAL = "CRITICAL",
}

// -----------------------------
// Responsibility Tag
// -----------------------------
export interface ResponsibilityTag {
  /** Unique ID for the interaction chain */
  trace_id: string;
  /** Module that generated this (e.g., "EthicalFilter", "ToneSoulAgent") */
  module_name: string;
  /** Unix timestamp (immutable time) */
  timestamp: number;
  /** Priority level at which the output was evaluated */
  priority_level: "P0" | "P1" | "P2" | "P3";
  /** Calculated risk value associated with the output */
  risk_score: number;
}

// -----------------------------
// Vow Object
// -----------------------------
export interface VowObject {
  /** UUID for this vow */
  vow_id: string;
  /** SHA‑256 hash of the full text content */
  content_hash: string;
  /** The actual text content generated by the system */
  full_text: string;
  /** Snapshot of the ToneSoul triad at generation time */
  triad_snapshot: ToneSoulTriad;
  /** Responsibility metadata for audit and traceability */
  responsibility: ResponsibilityTag;
  /** Whether this output was blocked by the Guardian Protocol */
  is_blocked: boolean;
}

// -----------------------------
// Ethical Ruling
// -----------------------------
export interface EthicalRuling {
  /** Whether the output is allowed (true) or blocked (false) */
  allowed: boolean;
  /** Code representing the type of violation, if any */
  violation_code?: string;
  /** The safe fallback text returned if blocked */
  enforced_text?: string;
  /** Explanatory reasoning for the decision */
  reasoning: string;
}

// -----------------------------
// Time Island
// -----------------------------
export interface TimeIsland {
  /** Unique identifier for the island */
  island_id: string;
  /** Collection of vow IDs associated with this island */
  vows: string[];
  /** Timestamp marking when the island was created */
  created_at: number;
  /** Contextual metadata summarizing the island */
  summary: string;
}

// -----------------------------
// Vow Factory
// -----------------------------
/**
 * Factory class for creating VowObject instances.  The factory centralizes
 * hashing and triad assignment and provides convenience methods for
 * generating new vows.
 */
export class VowFactory {
  /**
   * Generates a SHA‑256 hash for the given content.  In a real
   * implementation you would import a crypto library; here we simulate
   * hashing with a simple stub for illustration.
   */
  static generateHash(content: string): string {
    // In production, use: import { createHash } from 'crypto';
    // return createHash('sha256').update(content).digest('hex');
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      // Simple non‑crypto hash as placeholder
      const chr = content.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0; // Convert to 32bit integer
    }
    return hash.toString(16);
  }

  /**
   * Creates a new vow with the provided text and metadata.  The caller must
   * supply a ToneSoul triad and responsibility tag computed upstream.
   */
  static createVow(
    full_text: string,
    triad: ToneSoulTriad,
    responsibility: ResponsibilityTag,
    is_blocked = false
  ): VowObject {
    const vow_id = crypto.randomUUID?.() ??
      [1e7]+-1e3+-4e3+-8e3+-1e11.replace(/[018]/g, (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    const content_hash = this.generateHash(full_text);
    return {
      vow_id,
      content_hash,
      full_text,
      triad_snapshot: triad,
      responsibility,
      is_blocked,
    };
  }
}

// Note: this file intentionally does not export any concrete functions beyond
// type declarations and the factory.  All runtime logic should live in the
// body layer (e.g., spine_system.py).  This separation of concerns helps
// ensure that contracts remain stable and easily consumable by TypeScript
// clients.
